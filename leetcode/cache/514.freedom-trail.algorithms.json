{"id":514,"fid":"514","name":"自由之路","slug":"freedom-trail","link":"https://leetcode.cn/problems/freedom-trail/description/","percent":54.35927291545378,"level":"Hard","category":"algorithms","en_name":"Freedom Trail","cn_name":"自由之路","totalAC":"42K","totalSubmit":"77.3K","likes":330,"dislikes":0,"desc":"<p>电子游戏“辐射4”中，任务 <strong>“通向自由”</strong> 要求玩家到达名为 “<strong>Freedom Trail Ring”</strong> 的金属表盘，并使用表盘拼写特定关键词才能开门。</p>\n\n<p>给定一个字符串&nbsp;<code>ring</code>&nbsp;，表示刻在外环上的编码；给定另一个字符串&nbsp;<code>key</code>&nbsp;，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的<strong>最少</strong>步数。</p>\n\n<p>最初，<strong>ring&nbsp;</strong>的第一个字符与 <code>12:00</code> 方向对齐。您需要顺时针或逆时针旋转 <code>ring</code> 以使&nbsp;<strong>key&nbsp;</strong>的一个字符在 <code>12:00</code> 方向对齐，然后按下中心按钮，以此逐个拼写完&nbsp;<strong><code>key</code>&nbsp;</strong>中的所有字符。</p>\n\n<p>旋转&nbsp;<code>ring</code><strong>&nbsp;</strong>拼出 key 字符&nbsp;<code>key[i]</code><strong>&nbsp;</strong>的阶段中：</p>\n\n<ol>\n\t<li>您可以将&nbsp;<strong>ring&nbsp;</strong>顺时针或逆时针旋转&nbsp;<strong>一个位置&nbsp;</strong>，计为1步。旋转的最终目的是将字符串&nbsp;<strong><code>ring</code>&nbsp;</strong>的一个字符与 <code>12:00</code> 方向对齐，并且这个字符必须等于字符&nbsp;<strong><code>key[i]</code> 。</strong></li>\n\t<li>如果字符&nbsp;<strong><code>key[i]</code>&nbsp;</strong>已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作&nbsp;<strong>1 步</strong>。按完之后，您可以开始拼写&nbsp;<strong>key&nbsp;</strong>的下一个字符（下一阶段）, 直至完成所有拼写。</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/22/ring.jpg\" style=\"height: 450px; width: 450px;\" /></p>\n\n<center>&nbsp;</center>\n\n<pre>\n<strong>输入:</strong> ring = \"godding\", key = \"gd\"\n<strong>输出:</strong> 4\n<strong>解释:</strong>\n 对于 key 的第一个字符 'g'，已经在正确的位置, 我们只需要1步来拼写这个字符。 \n 对于 key 的第二个字符 'd'，我们需要逆时针旋转 ring \"godding\" 2步使它变成 \"ddinggo\"。\n 当然, 我们还需要1步进行拼写。\n 因此最终的输出是 4。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> ring = \"godding\", key = \"godding\"\n<strong>输出:</strong> 13\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= ring.length, key.length &lt;= 100</code></li>\n\t<li><code>ring</code>&nbsp;和&nbsp;<code>key</code>&nbsp;只包含小写英文字母</li>\n\t<li><strong>保证</strong> 字符串&nbsp;<code>key</code>&nbsp;一定可以由字符串 &nbsp;<code>ring</code>&nbsp;旋转拼出</li>\n</ul>\n","templates":[{"value":"cpp","text":"C++","defaultCode":"class Solution {\npublic:\n    int findRotateSteps(string ring, string key) {\n\n    }\n};"},{"value":"java","text":"Java","defaultCode":"class Solution {\n    public int findRotateSteps(String ring, String key) {\n\n    }\n}"},{"value":"python","text":"Python","defaultCode":"class Solution(object):\n    def findRotateSteps(self, ring, key):\n        \"\"\"\n        :type ring: str\n        :type key: str\n        :rtype: int\n        \"\"\""},{"value":"python3","text":"Python3","defaultCode":"class Solution:\n    def findRotateSteps(self, ring: str, key: str) -> int:"},{"value":"c","text":"C","defaultCode":"int findRotateSteps(char* ring, char* key) {\n    \n}"},{"value":"csharp","text":"C#","defaultCode":"public class Solution {\n    public int FindRotateSteps(string ring, string key) {\n\n    }\n}"},{"value":"javascript","text":"JavaScript","defaultCode":"/**\n * @param {string} ring\n * @param {string} key\n * @return {number}\n */\nvar findRotateSteps = function(ring, key) {\n\n};"},{"value":"typescript","text":"TypeScript","defaultCode":"function findRotateSteps(ring: string, key: string): number {\n    \n};"},{"value":"php","text":"PHP","defaultCode":"class Solution {\n\n    /**\n     * @param String $ring\n     * @param String $key\n     * @return Integer\n     */\n    function findRotateSteps($ring, $key) {\n\n    }\n}"},{"value":"swift","text":"Swift","defaultCode":"class Solution {\n    func findRotateSteps(_ ring: String, _ key: String) -> Int {\n\n    }\n}"},{"value":"kotlin","text":"Kotlin","defaultCode":"class Solution {\n    fun findRotateSteps(ring: String, key: String): Int {\n\n    }\n}"},{"value":"dart","text":"Dart","defaultCode":"class Solution {\n  int findRotateSteps(String ring, String key) {\n    \n  }\n}"},{"value":"golang","text":"Go","defaultCode":"func findRotateSteps(ring string, key string) int {\n\n}"},{"value":"ruby","text":"Ruby","defaultCode":"# @param {String} ring\n# @param {String} key\n# @return {Integer}\ndef find_rotate_steps(ring, key)\n    \nend"},{"value":"scala","text":"Scala","defaultCode":"object Solution {\n    def findRotateSteps(ring: String, key: String): Int = {\n        \n    }\n}"},{"value":"rust","text":"Rust","defaultCode":"impl Solution {\n    pub fn find_rotate_steps(ring: String, key: String) -> i32 {\n\n    }\n}"},{"value":"racket","text":"Racket","defaultCode":"(define/contract (find-rotate-steps ring key)\n  (-> string? string? exact-integer?)\n  )"},{"value":"erlang","text":"Erlang","defaultCode":"-spec find_rotate_steps(Ring :: unicode:unicode_binary(), Key :: unicode:unicode_binary()) -> integer().\nfind_rotate_steps(Ring, Key) ->\n  ."},{"value":"elixir","text":"Elixir","defaultCode":"defmodule Solution do\n  @spec find_rotate_steps(ring :: String.t, key :: String.t) :: integer\n  def find_rotate_steps(ring, key) do\n    \n  end\nend"},{"value":"cangjie","text":"Cangjie","defaultCode":"class Solution {\n    func findRotateSteps(ring: String, key: String): Int64 {\n\n    }\n}"}],"testcase":"\"godding\"\n\"gd\"","testable":true,"templateMeta":{"name":"findRotateSteps","params":[{"name":"ring","type":"string"},{"name":"key","type":"string"}],"return":{"type":"integer"}}}